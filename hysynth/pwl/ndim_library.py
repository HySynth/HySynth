import ppl
import hysynth.pwl.library as lib


# ---------------------------------------------------------------------------------------#
def slope_to_ray(vector):
    """ Obtain a ray from a given vector.
	------------------------------------------------------------------------------------
	input:	slope		Vector of slopes		list of floats

	output:	ray         Ray		                ppl.Generator.ray """

    int_ray_vector = lib.float2int(vector)
    ppl_ray = ppl.Generator.ray(ppl.Linear_Expression(int_ray_vector, 0))

    return ppl_ray


# ---------------------------------------------------------------------------------------#
def npost(initpoly, finalpoly, slope_vector):
    """ Obtain a reach polyhedron given two polyhedra, the initial and the final one,
	and the slope vector of the dynamics.
	------------------------------------------------------------------------------------
	input:	initpoly		Initial polyhedron		ppl.NNC_Polyhedron
			finalpoly		Final polyhedron		ppl.NNC_Polyhedron
			slope			Dynamical slope			list of float

	output:	reachpoly		Reach polyhedron		ppl.NNC_Polyhedron. """


    dim = initpoly.space_dimension()

    if initpoly.is_empty() or finalpoly.is_empty() or slope_vector is None:
        reachpoly = ppl.NNC_Polyhedron(dim, 'empty')

    else:

        # Get the generators from the initial polyhedron
        initgen = initpoly.minimized_generators()

        # Minkowski's sum of the initial polyhedron and the dynamics
        gen = ppl.Generator_System()

        # generators of the initial polyhedron
        for g in initgen:
            gen.insert(g)

        # ray of the dynamics determined by the slope
        # We add the coefficient for the coordinate time, which corresponds to Variable(0)
        aux_slope_vector = slope_vector[:]
        aux_slope_vector.insert(0, 1)
        ppl_ray = slope_to_ray(aux_slope_vector)

        # insert ray into the generators
        gen.insert(ppl_ray)
        # 	print 'generators =',gen

        # construct the polyhedron generated by the initial polyhedron and the dynamics
        reachpoly = ppl.NNC_Polyhedron(gen)
        # 	print 'reachpoly =',reachpoly.minimized_constraints()

        # Intersection of the Minkowski's sum and final polyhedron,
        # which gives the reach set.
        reachpoly.intersection_assign(finalpoly)
        # 	print 'reachpoly after intersection =',reachpoly.minimized_constraints()

    return reachpoly



# ---------------------------------------------------------------------------------------#
def npre(initpoly, finalpoly, slope_vector):
    """ Obtain a reach polyhedron given two polyhedra, the initial and the final one,
	and the slope of the dynamics.
	------------------------------------------------------------------------------------
	input:	initpoly		Initial polyhedron		ppl.NNC_Polyhedron
			finalpoly		Final polyhedron		ppl.NNC_Polyhedron
			slope			Dynamical slope			list of float

	output:	reachpoly		Reach polyhedron		ppl.NNC_Polyhedron. """

    dim = initpoly.space_dimension()

    if initpoly.is_empty() or finalpoly.is_empty() or slope_vector is None:
        reachpoly = ppl.NNC_Polyhedron(dim,'empty')

    else:
        # Get the generators from the initial polyhedron
        initgen = initpoly.minimized_generators()

        # Minkowski's sum of the initial polyhedron and the dynamics
        gen = ppl.Generator_System()

        # generators of the initial polyhedron
        for g in initgen:
            gen.insert(g)


        # ray of the dynamics determined by the slope
        aux_slope_vector = slope_vector[:]
        aux_slope_vector.insert(0, 1)
        # Change the sign for every coefficient in ray_vector
        minus_ray_vector = [-x for x in aux_slope_vector]
        ppl_ray = slope_to_ray(minus_ray_vector)

        # insert ray into the generators
        gen.insert(ppl_ray)
        # 	print 'generators =',gen

        # construct the polyhedron generated by the initial polyhedron and the dynamics
        reachpoly = ppl.NNC_Polyhedron(gen)
        # 	print 'reachpoly =',reachpoly.minimized_constraints()

        # Intersection of the Minkowski's sum and final polyhedron,
        # which gives the reach set.
        reachpoly.intersection_assign(finalpoly)

    return reachpoly


# ---------------------------------------------------------------------------------------#
def switching_reach_AB(index, polyhedron_P, pwl_function_tube, switching_guard, init_dynamics = None, final_dynamics = None, final_time = 0):

    dim = polyhedron_P.space_dimension()

    # In case that the index is the first one
    if index == 0:

        final_piece_tube = pwl_function_tube[index]
        aux_poly_A = ppl.NNC_Polyhedron(final_piece_tube)
        aux_poly_A.add_constraint(ppl.Variable(0) == 0)

        polyhedron_A = lib.intersection(aux_poly_A, switching_guard)
        polyhedron_B = ppl.NNC_Polyhedron(polyhedron_A)

    else:
        init_piece_tube = pwl_function_tube[index - 1]
        # In case that the index is the last one
        if index == len(pwl_function_tube):

            # final tube piece (not empty by construction)
            polyhedron_tube_intersection = ppl.NNC_Polyhedron(init_piece_tube)
            # Add final time in the the pwl function as a constraint (ppl.Variable(0) == final_time)
            time_linexp = lib.integer_time_constraint(polyhedron_tube_intersection.space_dimension(), final_time)
            polyhedron_tube_intersection.add_constraint(time_linexp == 0)

            if not switching_guard.is_universe():
                polyhedron_tube_intersection.intersection_assign(switching_guard)

            if polyhedron_tube_intersection.is_empty():
                polyhedron_A = ppl.NNC_Polyhedron(dim, 'empty')
            else:
                polyhedron_A = npost(polyhedron_P, polyhedron_tube_intersection, init_dynamics)

            polyhedron_B = ppl.NNC_Polyhedron(dim, 'empty')

        else:

            final_piece_tube = pwl_function_tube[index]

            # Intersection of the two tube pieces (not empty by construction)
            polyhedron_tube_intersection = ppl.NNC_Polyhedron(init_piece_tube)
            polyhedron_tube_intersection.intersection_assign(final_piece_tube)

            if switching_guard.is_universe():
                switching_guard_A = ppl.NNC_Polyhedron(init_piece_tube)
                switching_guard_B = ppl.NNC_Polyhedron(final_piece_tube)
            else:
                switching_guard_A = ppl.NNC_Polyhedron(switching_guard)
                switching_guard_A.intersection_assign(init_piece_tube)

                switching_guard_B = ppl.NNC_Polyhedron(switching_guard)
                switching_guard_B.intersection_assign(final_piece_tube)

            if switching_guard_A.is_empty():
                polyhedron_A = ppl.NNC_Polyhedron(dim, 'empty')
            else:
                # Computation of the region where executions included in the delta-tube
                # of f can start
                auxA = npost(polyhedron_P, switching_guard_A, init_dynamics)
                polyhedron_A = npre(polyhedron_tube_intersection, auxA, final_dynamics)

            if switching_guard_B.is_empty():
                polyhedron_B = ppl.NNC_Polyhedron(dim, 'empty')
            else:
                auxB = npre(polyhedron_tube_intersection, polyhedron_P, init_dynamics)
                polyhedron_B = npost(auxB, switching_guard_B, init_dynamics)

    return polyhedron_A, polyhedron_B



# ---------------------------------------------------------------------------------------#
def switching_reach_P(index, polyhedron_P, init_dynamics, final_dynamics, pwl_function_tube, switching_guard, final_time = 0):

    polyhedron_A, polyhedron_B = switching_reach_AB(index, polyhedron_P, pwl_function_tube, switching_guard, init_dynamics, final_dynamics, final_time)

    next_polyhedron_P = ppl.NNC_Polyhedron(polyhedron_A)
    next_polyhedron_P.poly_hull_assign(polyhedron_B)

    return next_polyhedron_P


# --------------------------------------------------------------------------------------------------------------------#
def ha_switching_reach_AB(index, max_index, polyhedron_P, hybrid_automaton, ha_path, pwl_function, pwl_function_tube):

    dim = hybrid_automaton.dim + 1

    # If the index is zero
    if index == 0:

        next_location = ha_path[0]
        invariant = hybrid_automaton.get_invariant(next_location)

        poly_A, poly_B = switching_reach_AB(index=index,
                                            polyhedron_P=polyhedron_P,
                                            pwl_function_tube=pwl_function_tube,
                                            switching_guard=invariant)

    else:

        current_location = ha_path[index - 1]

        if current_location is None:

            poly_A = ppl.NNC_Polyhedron(dim, 'empty')
            poly_B = ppl.NNC_Polyhedron(dim, 'empty')

        else:

            init_flow = hybrid_automaton.get_flow(current_location)

            # If the index is the last one, there is no final flow
            if index == max_index:

                invariant = hybrid_automaton.get_invariant(current_location)

                poly_A, poly_B = switching_reach_AB(index=index,
                                                    polyhedron_P = polyhedron_P,
                                                    pwl_function_tube=pwl_function_tube,
                                                    switching_guard=invariant,
                                                    init_dynamics=init_flow,
                                                    final_time=pwl_function[-1][0])

            else:

                next_location = ha_path[index]

                if next_location is None or (current_location, next_location) not in hybrid_automaton.edges:

                    poly_A = ppl.NNC_Polyhedron(dim, 'empty')
                    poly_B = ppl.NNC_Polyhedron(dim, 'empty')

                else:

                    final_flow = hybrid_automaton.get_flow(next_location)
                    guard = hybrid_automaton.get_guard((current_location, next_location))
                    poly_A, poly_B = switching_reach_AB(index=index,
                                                        polyhedron_P=polyhedron_P,
                                                        pwl_function_tube=pwl_function_tube,
                                                        switching_guard=guard,
                                                        init_dynamics=init_flow,
                                                        final_dynamics=final_flow)

    return poly_A, poly_B


# --------------------------------------------------------------------------------------------------------------------#
def flow_switching_reach_P_index(index, max_index, initial_index, flow_list, A_list, B_list, polyhedron_P, pwl_function, pwl_function_tube):



    dim = len(pwl_function[0])
    final_time = pwl_function[-1][0]

    # Initialization
    # if initial_index == 0:
    #     polyhedron_P = lib.convex_hull(list_A[initial_index], list_B[initial_index])
    #
    # else:
    #     polyhedron_P = lib.convex_hull(list_A[initial_index - 1], list_B[initial_index - 1])

    # In case that index, initial_index and max_index are all equal, there is no possible
    # switching computation
    # if index == initial_index and initial_index == max_index:
    if initial_index == max_index:

        polyhedron_P = ppl.NNC_Polyhedron(dim, 'empty') # Should it be polyhedron_P = A_list[max_index]

    else:
        switching_guard = ppl.NNC_Polyhedron(dim,'universe')

        if initial_index == 0:

            polyhedron_P = ppl.NNC_Polyhedron(dim, 'empty') # This does not mind

        else:

            polyhedron_P = lib.convex_hull(A_list[initial_index - 1], B_list[initial_index - 1])

        # Polyhedron P computation loop
        for i, j in zip(range(initial_index, index + 1), range(index - initial_index + 1)):

            if i == 0:

                initial_flow = None
                final_flow = flow_list[j]

            elif i == max_index:

                initial_flow = flow_list[j - 1]
                final_flow = None

            else:

                initial_flow = flow_list[j - 1]
                final_flow = flow_list[j]


            polyhedron_A, polyhedron_B = switching_reach_AB(index=i,
                                                            polyhedron_P=polyhedron_P,
                                                            init_dynamics=initial_flow,
                                                            final_dynamics=final_flow,
                                                            pwl_function_tube = pwl_function_tube,
                                                            switching_guard=switching_guard,
                                                            final_time=final_time)

            A_list[i] = polyhedron_A
            B_list[i] = polyhedron_B

            polyhedron_P = lib.convex_hull(polyhedron_A, polyhedron_B)

    return polyhedron_P, A_list, B_list


# --------------------------------------------------------------------------------------------------------------------#
def flow_switching_reach_P_index_test(index, max_index, initial_index, flow_list, A_list, B_list, polyhedron_P, pwl_function, pwl_function_tube):



    dim = len(pwl_function[0])
    final_time = pwl_function[-1][0]

    # Initialization
    # if initial_index == 0:
    #     polyhedron_P = lib.convex_hull(list_A[initial_index], list_B[initial_index])
    #
    # else:
    #     polyhedron_P = lib.convex_hull(list_A[initial_index - 1], list_B[initial_index - 1])

    # In case that index, initial_index and max_index are all equal, there is no possible
    # switching computation
    # if index == initial_index and initial_index == max_index:
    if initial_index == max_index:

        polyhedron_P = ppl.NNC_Polyhedron(dim, 'empty') # Should it be polyhedron_P = A_list[max_index]

    else:
        switching_guard = ppl.NNC_Polyhedron(dim,'universe')

        if initial_index == 0:

            polyhedron_P = ppl.NNC_Polyhedron(dim, 'empty') # This does not mind

        else:

            polyhedron_P = lib.convex_hull(A_list[initial_index - 1], B_list[initial_index - 1])

        # Polyhedron P computation loop
        # for i, j in zip(range(initial_index, index + 1), range(index - initial_index + 1)):
        for i in range(initial_index, index + 1):

            if i == 0:

                initial_flow = None
                final_flow = flow_list[i]

            elif i == max_index:

                initial_flow = flow_list[i - 1]
                final_flow = None

            else:

                initial_flow = flow_list[i - 1]
                final_flow = flow_list[i]


            polyhedron_A, polyhedron_B = switching_reach_AB(index=i,
                                                            polyhedron_P=polyhedron_P,
                                                            init_dynamics=initial_flow,
                                                            final_dynamics=final_flow,
                                                            pwl_function_tube = pwl_function_tube,
                                                            switching_guard=switching_guard,
                                                            final_time=final_time)

            A_list[i] = polyhedron_A
            B_list[i] = polyhedron_B

            polyhedron_P = lib.convex_hull(polyhedron_A, polyhedron_B)

    return polyhedron_P, A_list, B_list






def ndim_slope_bound(init_point, final_point, delta):
    """ Obtain a flow in the hybrid automaton H which is close to the slope form by
    joining two points: initial and final. """

    init_t = init_point[0]  # Initial time instant
    final_t = final_point[0]  # Final time instant

    init_x = init_point[1:]  # Initial value
    final_x = final_point[1:]  # Final value

    # Exact slope
    slope_vector = lib.slopes([init_point, final_point])[0] #final_x - init_x) / (final_t - init_t)  # this is the slope value

    # Upper bound for the slope value
    final_x_up = [x + delta for x in final_x]
    slope_upper = [(x - y) / (final_t - init_t) for x, y in zip(final_x_up, init_x)]

    # Lower bound for the slope value
    final_x_low = [x - delta for x in final_x]
    slope_lower = [(x - y) / (final_t - init_t) for x, y in zip(final_x_low, init_x)]

    return slope_vector, slope_lower, slope_upper


def ndim_similar_flow_mode(init_point, final_point, hybrid_automaton):
    """ Obtain a flow in the hybrid automaton H which is close to the slope form by
    joining two points: initial and final. """

    slope, slope_lower, slope_upper = ndim_slope_bound(init_point, final_point, hybrid_automaton.delta)

    min_diff_slope = [float('inf')]*len(slope)
    resulting_mode = None

    for curr_mode_name, flow in hybrid_automaton.flows.items():
        # current flow
        #flow = flow["var1"]

        flow_between_bounds = True
        flow_closer_to_slope = True

        for i in range(len(slope)):

            flow_between_bounds = flow_between_bounds and (slope_lower[i] <= flow[i] <= slope_upper[i])
            flow_closer_to_slope = flow_closer_to_slope and (flow[i] - slope[i] < min_diff_slope[i])


        # if slope_lower <= flow <= slope_upper and flow - slope < min_diff_slope:
        if flow_between_bounds and flow_closer_to_slope:
            min_diff_slope = [x - y for x,y in zip(flow, slope)]
            resulting_mode = curr_mode_name

    return resulting_mode
